
# name of package
name = "niagara-ast"
skeleton = "library"

# version if different from project version
# version = "0.1.0"

# synopsis if different from project synopsis
# synopsis = ...

# description if different from project description
# description = ...

# kind is either "library", "program" or "virtual"
kind = "library"

# authors if different from project authors
# authors = [ "Me <me@metoo.org>" ]

# name of a file to generate with the current version
gen-version = "version.ml"

# supported file generators are "ocamllex", "ocamlyacc" and "menhir" 
# default is [ "ocamllex", "ocamlyacc" ] 
generators = []

# menhir options for the package
#Example:
#version = "2.0"
#parser = { modules = ["parser"]; tokens = "Tokens" }
#tokens = { modules = ["tokens"]}
# menhir = ...

# whether all modules should be packed/wrapped (default is true)
# pack-modules = true

# whether the package can be silently skipped if missing deps (default is false)
# optional = true

# module name used to pack modules (if pack-modules is true)
# pack = "Frontend"

# preprocessing options
#  preprocess = "per-module (((action (run ./toto.sh %{input-file})) mod))" 
preprocess = "pps sedlex.ppx"

# files to skip while updating at package level
# skip = []

# package library dependencies
#   [dependencies]
#   ez_file = ">=0.1 <1.3"
#   base-unix = { libname = "unix", version = ">=base" } 
[dependencies]
niagara-utils = "version"
sedlex = ">=3.0"
menhirLib = ""
ocamlgraph = ""
calendar = ">=3.0"

# package tools dependencies
[tools]
menhir = ""

# package fields (depends on package skeleton)
#Examples:
#  dune-stanzas = "(preprocess (pps ppx_deriving_encoding))" 
#  dune-libraries = "bigstring" 
#  dune-trailer = "(install (..))" 
#  opam-trailer = "pin-depends: [..]" 
#  no-opam-test = "yes" 
#  no-opam-doc = "yes" 
#  gen-opam = "some" | "all" 
#  dune-stanzas = "(flags (:standard (:include linking.sexp)))" 
#  static-clibs = "unix" 
[fields]
dune-trailer = """

; Grammar maintenance utilities

(menhir
 (modules parser)
 (flags -v --table)
)

(rule
 (with-stdout-to
  parser.messages.new
  (run
   menhir
   %{dep:parser.mly}
   --list-errors)))

(rule
 (mode fallback)
 (action
  (copy parser.messages.new parser.messages)))

(rule
 (with-stdout-to
  parserErrors.ml
  (run
   menhir
   %{dep:parser.mly}
   --compile-errors
   %{dep:parser.messages})))

(rule
 (with-stdout-to
  parser.messages.updated
  (run
   menhir
   %{dep:parser.mly}
   --merge-errors
   %{dep:parser.messages.new}
   --merge-errors
   %{dep:parser.messages})))

(rule
 (mode promote) ; doesn't works, why?
 (alias update-parser-messages)
 (action
  (diff parser.messages %{dep:parser.messages.updated})))
"""
